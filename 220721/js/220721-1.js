/*
1.代码分类
全局代码
局部代码（函数）
2.全局执行上下文
在执行全局代码前将window确定为全局执行上下文
对全局执行数据进行预处理
var进行所谓全局变量   undefined  添加window的属性
function声明的全局函数  赋值  添加window的方法
this 赋值window

3.函数执行上下文
在调用函数时，准备执行函数体之前，创建对应函数执行上下文对象（虚拟的，存在于栈中）
对局部数据进行预处理
形参变量  赋值（实参）  添加微执行上下文的属性
arguments  赋值  添加为执行上下文的属性
var 定义的局部变量   undefined  
function声明的函数  赋值fun 
this 赋值 
开始执行函数体代码
*/

//1.一共执行多少次执行上下文
var a=10;
var bar=function(x){
var b=5;
foo(x+b);
}
var foo=function(y){
var c=5;
console.log(a+c+y);
}
bar(10);
/*
首先是window,并且这个存在于栈的最底端，一直用到最后，栈的特点是先进后出
当函数执行调用时才算是一次执行上下文，所以bar（10）算一个
foo(x+b)算一个
那么一共共三个
*/


console.log("---------分界线---------");
//2.整个过程一共产生了几个执行上下文
console.log('gb:'+i);//gb=undefined
var i=1;
foo(1);
function foo(i){
    if(i==4){
        return;
    }
    console.log('fb:'+i);
    foo(i+1);
    console.log('fe:'+i);
}
/*
首先肯定是window
当函数执行调用时算一次执行上下文，所以foo(1)算一次
然后呢，执行foo(1)函数，此时i！=4，所以输出fb:1
foo(i+1)=foo(2),2!=4,输出fb:2
foo(2+1)=foo(3),3!=4,输出fb:3
foo(3+1)=foo(4),4=4,return返回52行终止
执行53行，此时根据栈的图，foo(4)没有执行下去，执行完被销毁此时i=3
53行输出fe:3,也就是f3,fe3出去  fe2出去  fe1出去

？？？
*/

//面试题1
function a2(){ };
var a2;
console.log(typeof a2);//function
/*
先执行变量提升，再执行函数提升。
*/

function a3(){ };
var a3=1;
console.log(typeof a3);//number
/*
先执行变量提升，再执行函数提升。
函数提升优先级比变量提升要高，且不会被变量声明覆盖，但是会被变量赋值覆盖
*/

//面试题2
if(!(b in window)){//如果b in window正确，那么！（）不会执行，直接输出b
    var b=1;
}
console.log(b);//如果输出来是1，那么b就是变量
//结果输出为undefined 
/*
//结果输出为undefined ,所以b in window
*/

//面试题3
var c2=1;
function c2(c2){
    console.log(c);
    var c=3;
}

//c2(2);//会报错不是一个函数，根本就不会执行function里头的代码

/*
先执行变量提升，再执行函数提升。
函数提升优先级比变量提升要高，且不会被变量声明覆盖，但是会被变量赋值覆盖
此时就是被变量赋值覆盖到了
console.log(c2);//1
*/

/*
作用域与作用域链
1.理解：
就是一个代码段所在的区域
他是静态的（相对于上下文对象），在编写代码就确定的
2.分类：
全局作用域
函数作用域
3.作用：
隔离变量，不同作用域下同名变量不会有冲突相同名的变量名在不同的作用域互不相影响
*/

/*
作用域和上下文对象之间的区别
区别1:
全局作用域之外，每个人函数都会创建自己的作用域，作用域在函数定义时就已经确定了。
而不是在函数调用时才有的。
全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建。是在函数调用时，才有上下文对象的
函数执行上下文环境是在调用函数时，函数体代码执行之前创建

区别2:
作用域是静态的，只要函数定义好了就一直存在，且不会在变化
而上下文环境是动态的，调用函数时创建，函数调用结束时上下文环境就会被释放

联系：
上下文环境是属于所在的作用域
全局上下文环境  全局作用域
函数上下文环境  对应函数使用域
*/

//函数作用域里面内部的能看到外部的，能向外部寻找，而外部的全局作用域却看不到里面的
var a4=10,
b4=20;
function fn(x4){
    var a4=100,
    c4=300;
    console.log('fn()',a4,b4,c4,x4);//首先在自己的fn()作用域里找，a4=100,c4=300,x4=10.
    //而剩下的找不到，便去全局作用域里找b4=20
    //100 20  300 10
    function bar(x4){
        var a4=1000;
        d4=400;
        console.log('bar()',a4,b4,c4,d4,x4);//同样先在自己的bar()作用域里找，a4=1000,d4=400,x4=100
        //找不到往他的父级作用域里找，发现在第一个父级作用域fn()中，c4=300,d4找不到
        //接下来在进入下一个父级作用域里找也就是全局作用域，得到b4=20
        //1000 20 300 400 100
    }
    bar(100);
    //bar(200)
}
fn(10);


//面试题1
var x5=10;//全局作用域
function fn1(){
console.log(x5);
}//作用域fn1
function show(f){
    var x5=20;
    f();
}//作用域show
show(fn1);
/*
首先调用执行shou(fn1),得到show function里面的代码
也就是var x5=20,f()   ，实际参数传过来的是一个函数，也就是第一个函数
而f(),也就是传进来的函数，f1()
得到的是fn1里的代码，console.log(x5)
 
那这个console.log(x5)输出来的是什么呢
首先在自己fn1()自己的作用域上找，发现没有找到，继续往全局作用域里找，得到x5=10
*/

//面试题2
var fn2=function(){
    console.log(fn2);
}
fn2();//{console.log(fn2);}

var obj={
    fn3:function(){
        console.log(fn3);
    }
}
//obj.fn3();//报错，找不到，因为fn3是属性，并不是变量

//用for循环之后绑定单机响应函数，循环遍历结果i都是最大的长度
//这是因为事件的响应函数是点击的时候才触发调用的。响应函数是在for循环之后的，这个时候能够触发单机响应函数说明for循环已经执行完了
//因为只有for循环执行完才会给每个按钮都绑定上
//因为每循环一次这个函数都会立即执行，而上面那种是点击之后才执行的


/*
1.如何产生闭包
当一个嵌套的内部（子）函数引用外部（父）函数时，就产生了闭包
2.闭包到底是什么
使用chorme调试查看
理解一：闭包是嵌套的内部函数（绝大部分）
理解二：包含被引用变量（函数）的对象（极少部分人）
注意：闭包存在于嵌套的内部函数中
3.产生闭包的条件
函数嵌套
内部函数引用外部函数的数据（变量/函数）
*/
function fn5(){
    var a5=2;
var b5='abc';
function fn4(){
    console.log(a5);
}
}
fn5();

/*
常见的闭包
将一个函数作为另一个函数的返回值
将函数作为实参传递给另一个函数调用
*/
//将一个函数作为另一个函数的返回值
function fn6(){
    var a6=2;
    function fn7(){
        a6++;
        console.log(a6);//3
    }
    return fn7();
}
fn6();
//如何看闭包共有几个，就看外部函数执行几次，现在外部函数是fn6(),有一个fn6(),所以有一个闭包，跟内部函数执行几次没有关系，所以内部函数的数据不会消失

//将函数作为实参传递给另一个函数调用
function showDelay(msg,time){
setTimeout(function(){
    alert(msg);
},time);
}
showDelay('hello',200);
//有闭包，有内外部函数，内部函数引用外部函数的变量，是因为msg,不是time，要看{},因为闭包要看被引用的对象，被引用{}


//闭包的作用
/*
使用函数内部的变量在函数执行完之后，依然存活在内存中（延长局部变量的生存周期）
让函数外部可以操作（读写）函数内部的数据（变量/函数）
*/
/*
问题：
函数执行完，函数内部声明的变量依然存活吗
在函数外部能够访问函数内部的局部变量吗
*/